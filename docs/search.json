[
  {
    "objectID": "simulate_outbreak.html",
    "href": "simulate_outbreak.html",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "",
    "text": "This script provides a conceptual workflow that simulates farm locations, performes atmospheric dispersion modeling from a source farm (aka, plume modeling), analyizes the plume results in a spatial temporal model, and then identifies the simulated farms most vulnerable to airborne virus introduction. The results from this forward simulation are analysed in a second script BACKTRACE in an attempt to identify the soirce farms using only the information from the secondarily infected farms simulated here."
  },
  {
    "objectID": "simulate_outbreak.html#preliminary-setup",
    "href": "simulate_outbreak.html#preliminary-setup",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Preliminary Setup",
    "text": "Preliminary Setup\n\nLibraries\nThis workflow uses the renv package for package versioning and environmental management. The renv.lock file is included to facilitate package installain. See, renv::restore().\n\n\n\n\n\nCore Functions\nCustom functions\n\n\nHide code\nsource(here(\"R/utilities.R\"))\nsource_dir(here(\"R\"))\n\n\n\n\nAuthentication\nUser credentials to access data repository and API resources.\n\n\nHide code\nauthentications <- yaml::read_yaml(here(\"local\", \"secrets.yaml\"))\n\n\n\n\nAPI Registration\nStadia maps are used for backgrounds.\n\n\nHide code\nregister_stadiamaps(key = authentications$stadi_api)\n\n\n\n\nOSF Link\nModels and data generated from this script are stored at the Open Science Framwork (OSF) for remote access. See, this OSF Project: https://osf.io/98hmt/\n\n\nHide code\nosf_auth(authentications$osf_token) # for write/admin privileges\n\n\nRegistered PAT from the provided token\n\n\nHide code\nosf_project_demo <- osf_retrieve_node(\"https://osf.io/su4yz/\")\n\nosf_project_demo$name # scratch directory on OSF EpiPlume project\n\n\n[1] \"Demonstration Data\""
  },
  {
    "objectID": "simulate_outbreak.html#read-configuration-parameters",
    "href": "simulate_outbreak.html#read-configuration-parameters",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Read Configuration Parameters",
    "text": "Read Configuration Parameters\nParameters for epidemiological and spatial analyses are recorded in configuration files. Loading the demonstration config file, which can be viewed here: Demo Configuration Parameters.\n\n\nHide code\ncfg <- yaml::read_yaml(here(\"config\", \"demo_2025-04-21.yaml\"))"
  },
  {
    "objectID": "simulate_outbreak.html#create-study-area",
    "href": "simulate_outbreak.html#create-study-area",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Create Study Area",
    "text": "Create Study Area\nFrom a given lat-long, the define_study_domain() function constructs a surronding square grid at a specified extent and resolution to define a study area. The function optionally generates a specified number of simulated farms. The farms are randomly assigned within the study, based on chicken density estimated in the Gridded Livestock of the World Database (source). The more chickens at a location, the higher the probability that a random famr be placed there. The random farms are assigned a random flock size based on a possible range specified in the config file.\n\n\nHide code\nstudy_area_args <- c(\n  cfg$domain, # from config\n  list(\n    seed      = 123,\n    min_flock = 15000,\n    max_flock = 50000\n  )\n)\n\nstudy_area <- exec(define_study_domain, !!!study_area_args)\n\n\n# attributes\nstr(study_area)\n\n\nList of 4\n $ projection  : chr \"+proj=utm +zone=16 +north +datum=WGS84 +units=m +no_defs\"\n $ grid        :S4 class 'SpatRaster' [package \"terra\"]\n $ source_point:S4 class 'SpatVector' [package \"terra\"]\n $ farm_locs   :S4 class 'SpatVector' [package \"terra\"]\n\n\nHide code\n# flock sizes\nrange(study_area$farm_locs$flock)\n\n\n[1] 15861 49799\n\n\n\nflock size at source farm\nFor the demo, the centermost farm used in defining the study area is considered the source of pathogen emission. The flock size is need for that location to estimate emission.\n\n\nHide code\nsource_flock_n <- values(study_area$farm_locs) %>%\n  filter(farm == \"source\") %>%\n  select(flock)\n\nsource_flock_n\n\n\n\n\n\n\nflock\n\n\n\n\n19998\n\n\n\n\n\n\n\n\nPlot Study Area\nTHe source is the centermost triangle, other farms are shown as circles.\n\n\nHide code\nmap_grid(study_area$grid, source_loc = study_area$farm_locs)\n\n\n\n\n\nFigureÂ 1: Study area for analysis with simulated farms as indicated in legend."
  },
  {
    "objectID": "simulate_outbreak.html#simulate-outbreak",
    "href": "simulate_outbreak.html#simulate-outbreak",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Simulate Outbreak",
    "text": "Simulate Outbreak\n\nDates\nRandom dates for initial infection and virus emission from the source farm. Assuming detection occurs 5 to 20 days after outbreaks start. That is, when workers notice that chicken death rates are exceeding the normal background rate.\n\n\nHide code\nsim_dates <- random_infect_dates(year = 2020, month = 5, seed=1976)\nsim_dates\n\n\n$release_date\n[1] \"2020-05-27\"\n\n$infection_date\n[1] \"2020-05-15\"\n\n\n\n\nSEIR and Emission Estimates\nRun SEIR model for source farm. There are a ton of parameter assumptions here to discuss. Brief explanations are provided with the config file (linked here), but far too much to include in this draft workflow.\n\n\nHide code\n# virus decay, rate of decreasing viability\nhalflife <- calculate_half_life(viability_days = cfg$virus$viability_hours/24, # convert hours to days\n                                viability_threshold = cfg$virus$viability_threshold)\n\nargs <- list(\n  beta       = cfg$seir$beta,\n  sigma      = 1 / cfg$seir$sigma, # per/day\n  gamma      = 1 / cfg$seir$gamma, # per/day\n  qV         = cfg$virus$qV,\n  Vh         = cfg$poultry$house_vol,\n  Q          = cfg$poultry$Q_m3_h * 24, # to days\n  lamd       = log(2) / halflife, # virus decay\n  flock_size = source_flock_n$flock, # flock size at source farm\n  Ei         = cfg$seir$Ei,\n  Ii         = cfg$seir$Ii,\n  Ri         = cfg$seir$Ri,\n  Vi         = cfg$seir$Vi,\n  sim_days   = cfg$seir$sim_days,\n  infect_date = sim_dates$infection_date # initial infection\n)\n\nseir_out <- do.call(model_seir_shedding, args)\n\n\nGet rate on day of emission\n\n\nHide code\n# values for emission day\nsource_rate <- seir_out %>%\n  filter(datetime >= sim_dates$release_date & datetime < (sim_dates$release_date + days(1))) \n\n# range day of release\nrange(source_rate$V)\n\n\n[1] 30.43649 48.47731\n\n\n\n\nView SEIR Dynamics\nTop panel is SEIR result, bottom is estimated virus output at the the source farm.\n\n\nHide code\nplot_ode_shed_dynamics(seir_out, date_axis = TRUE, vline = sim_dates$release_date, vline_text = \"Emission\")"
  },
  {
    "objectID": "simulate_outbreak.html#plume-dispersion",
    "href": "simulate_outbreak.html#plume-dispersion",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Plume Dispersion",
    "text": "Plume Dispersion\nA HYSPLIT model is constructed based on the simulated outbreak and source farm emission dynamics. The splitR package is used to call a HYSPLIT exceutable from R.\n\n\nHide code\narbitrary_hour <- 12 # noon\nsimulated_realease_dt <- ymd_hm(paste0(sim_dates$release_date, \" \", sprintf(\"%02d:00\", arbitrary_hour)))\n\n\n\nRun plume model\nThe wrap_plume_model() function saves the plume model locally, however, a copy is also saved to OSF. There are a ton of parameter assumptions here to discuss. Brief explanations are provided with the config file (linked here), but its too much for this draft workflow.\n\n\nHide code\nplume_model <- wrap_plume_model(cfg, # configuration file\n                                plume_name = \"sim_demo\", # name/label\n                                rate = mean(source_rate$V), # rate from simulated outbreak\n                                release_start = simulated_realease_dt, # release from source farm\n                                release_end = simulated_realease_dt + hours(1), # hour long\n                                start_time = simulated_realease_dt, # dispersion time same as emission\n                                end_time = simulated_realease_dt + hours(24) # dispersion end\n                                )\n\n# copy to OSF for others to access (~500kb)\nosf_upload(osf_project_demo, path = here(\"local/demo_run/plume/sim_demo_model.rds\"))\n\n\nDownload plume model from OSF\n\n\nHide code\nosf_id <- osf_project_demo %>%\n  osf_ls_files() %>%\n  filter(name == \"sim_demo_model.rds\")\n\nosf_download(osf_id,\n             path = here(\"local/temp\"),\n             conflicts = \"overwrite\")\n\n\nRead plume model\n\n\nHide code\nplume_model <- readRDS(here(\"local/temp/sim_demo_model.rds\"))\n\n\n\n\nView complete simulated dispersion\nFull extent of plume\n\n\nHide code\nmap_grid2(study_area$grid, plume_model$disp_df, group_col = \"particle_i\", vector_type = \"point\", grid_cut=FALSE)\n\n\n\n\n\nPlume extent within study area\n\n\nHide code\nmap_grid2(study_area$grid, plume_model$disp_df, group_col = \"particle_i\", vector_type = \"point\", grid_cut=TRUE)\n\n\n\n\n\nA quick, low-weight animation as a spot check of time.\n\nanimate_disp <- animate_plume_simple(traj_data = plume_model$disp_df, \n                                     group_col = \"particle_i\", \n                                     point_size = 0.5, \n                                     source_loc=cfg$domain$source_origin)\n\nanimate_disp"
  },
  {
    "objectID": "simulate_outbreak.html#calculate-concentration",
    "href": "simulate_outbreak.html#calculate-concentration",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Calculate Concentration",
    "text": "Calculate Concentration\nThe calculate_particle_concentration() utilizes HYSPLIT estimated partcles to calculate the particles per m3 hour. Limiting analysis to first 6 hours, beyond that time the plume is outside the study area.\n\n\nHide code\nconcentration_lst <- calculate_particle_concentration(plume_table=plume_model$disp_df, \n                                                      raster_grid = study_area$grid,\n                                                      voxel_height = 50, # height (m)\n                                                      max_hour = 6) # maximum hour to use\n\n\n\nView Concentration\nViweing the first hour only.\n\n\nHide code\ncheck_hour <- 1\n\nmap_grid(study_area$grid, \n         source_loc = study_area$source_point, \n         concentration_raster = concentration_lst$concentration_stack[[check_hour]],\n         map_type = \"stamen_toner_lite\")\n\n\nâ¹ Â© Stadia Maps Â© Stamen Design Â© OpenMapTiles Â© OpenStreetMap contributors.\n\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\nGet concentration estimates for later analysis.\n\n\nHide code\nconcentration_df <- as.data.frame(concentration_lst$concentration_stack, xy = TRUE)\n\nconc_melt <- reshape2::melt(concentration_df, c(\"x\",\"y\"))\n\nconc_melt$hour <- as.integer(sub(\"^hour_\", \"\", conc_melt$variable))\n\nconc_melt <- conc_melt %>%\n  mutate(hour = as.integer(sub(\"^hour_\", \"\", variable)),\n         concen = value) %>%\n  select(-c(variable, value))"
  },
  {
    "objectID": "simulate_outbreak.html#spatiotemporal-modeling",
    "href": "simulate_outbreak.html#spatiotemporal-modeling",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Spatiotemporal Modeling",
    "text": "Spatiotemporal Modeling\nThe primary objective of spatial modeling is to account for spatial (s) and temporal (t) latency (error, variability) and uncertainty in HYSPLIT outputs. This smoothed results and enables uncertainty estimation. Just as importantly, developing the the HYSPLIT outputs to a spatiotemporal model allow for incorporating other variables, to include climate, land cover, farm specific biosecurity factors, and genetic samples to name a few.\nThe modeling framework here is a two-tiered joint model that concurrently estimates particle counts (tier 1, {y}_{1st}) and mass concentration (tier 2, {y}_{2st}) while accounting for correlated spatial and temporal factors as well as their interaction. These analyses follow a point-process framework, however concentration points in {y}_{2st} actually represent an area (grid cell). To help account for errors created when aggregating particles to grid cells, the random spatial field from the individual particles is shared with tier 2. In essence, individual particles act as a predictor or covariate for the cell-level concentration estimates.\nAs a joint model with two likelihoods, our response variable was specified as a bivariate matrix (i.e., Y = c({y}_{1st}, {y}_{2st}) where the first column was coded to indicate particle occurrence (1) or non-occurrence (0) such that,\n\n  \\textit{y}_{1st} =\n    \\begin{cases}\n      1, & \\text{particle present} \\\\\n      0, & \\text{no particle present} \\\\\n    \\end{cases}       \n\nThe second tier component modeled concentration where values were known, with\n\n  \\textit{y}_{2st} =\n    \\begin{cases}\n      NA, & \\text{concentration unknown} \\\\\n      concentration, & \\text{estimated concentration values}\n    \\end{cases}\n\nTo model airborne particulate matter using a binomial-gamma joint likelihood was used to separately represent particle probability and concentration. For particle detection (y_1st) was modeled using a Bernoulli distribution, while the latent concentration of particulate matter (y_2st) was modeled with a Gamma distribution:\n\ny_{1st} \\sim \\text{Bernoulli}(\\pi_{st})\n\n\ny_{2st} \\sim \\text{Gamma}(a_{st}, b_{st})\n\nwhere \\pi_{st} denotes the probability of detecting particulate matter at spatial location s and time t, and a_{st} and b_{st} are the Gamma shape and rate parameters, with mean \\mu_{st} = a_{st} / b_{st}.\nThe particle probability linear predictor was defined as:\n\n\\text{logit}(\\pi_{st}) = \\alpha^1 + \\zeta_{st}^1 + \\lambda S_{st}\n\nThe concentration linear predictor was defined as:\n\n\\log(\\mu_{st}) = \\alpha^2 + \\zeta_{st}^2 + \\frac{1}{\\lambda} S_{st}\n\nwhere:\n\n\\alpha^1 and \\alpha^2 are intercepts,\n\\zeta_{st} represents tier-specific spatial random effects,\nS_{st} is a shared spatiotemporal effect,\n\\lambda is a scaling parameter linking the probability and concentration models.\n\n\nConstruct mesh\nConstruct a tessellated mesh to define the study area\n\n\nHide code\nmesh.dom <- construct_mesh(\n  grid_raster = study_area$grid,\n  farm_locs = study_area$farm_locs)\n\n\nQuick check\n\n\nHide code\n# mesh.dom$n # number of nodes\n\nplot_mesh(mesh.dom)\n\n\n\n\n\n\n\nCombine data\nIndexing all data to ensure all time steps (hours 1-6) are represented and inserting NA where data is unknown.\n\n\nHide code\ncomb_data_in <- replicate_data_timesteps(grid_raster = study_area$grid,\n                                      farm_locs = study_area$farm_locs,\n                                      concen_data = conc_melt,\n                                      scale_concentration = 1e6,\n                                      plume_model = plume_model,\n                                      mesh = mesh.dom,\n                                      max_hour = 6)\n\n\n\n\nMesh projection\nAligning, matching, or projecting data to the mesh.\n\n\nHide code\n# flat prior based on study area width\nwidth_m <- dim(study_area$grid)[1]*res(study_area$grid)[1]/3\n\nsp_indices_dens <- project_to_mesh(comb_data = comb_data_in,\n                                   prior.range=c(width_m, 0.01),\n                                   prior.sigma=c(1, 0.01))"
  },
  {
    "objectID": "simulate_outbreak.html#organize-data",
    "href": "simulate_outbreak.html#organize-data",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Organize Data",
    "text": "Organize Data\nOrganizing all model inputs as list() objects. This is needed because data within and between model tiers are different dimensions (i.e., wonât fit in a common dataframe).\n\nIndividual particles\nOrganize tier 1 data for individual particles.\n\n\nHide code\ncomb_data_in$set_type <- as.integer(\n  as.factor(comb_data_in$set)\n)\n\ndens.lst <- list(c(sp_indices_dens$field.sp.1,\n                 list(intercept1 = 1)), \n                 list(height = comb_data_in[,\"height\"],\n                      hour_step.1 = comb_data_in[,\"hour\"],\n                      hour_step.2 = comb_data_in[,\"hour\"],\n                      hour_step.3 = comb_data_in[,\"hour\"],\n                      set_type = comb_data_in[,\"set_type\"])\n                )\n\ncomb_data_in$Yd <- ifelse(comb_data_in$set == \"particle\", 1, \n                      ifelse(comb_data_in$set == \"node\", 0, NA)\n)\n\ndens.stk <- inla.stack(data = list(Y = comb_data_in$Yd),\n                                 A = list(sp_indices_dens$A.mat, 1), \n                           effects = dens.lst,   \n                               tag = \"dens.0\")\n\nj.dens.stk <- inla.stack(data = list(Y = cbind(comb_data_in$Yd, NA), link = 1),\n                                 A = list(sp_indices_dens$A.mat, 1), \n                           effects = dens.lst,   \n                               tag = \"dens.0\")\n\n\n\n\nConcentration\nOrganize tier 2 data for aggregate particle measures (concentration).\n\n\nHide code\nconc.lst <- list(c(sp_indices_dens$field.sp.2,\n                 list(intercept2 = 1)), \n                 list(x = comb_data_in[,\"x\"],\n                      hour_step.1 = comb_data_in[,\"hour\"],\n                      hour_step.2 = comb_data_in[,\"hour\"],\n                      hour_step.3 = comb_data_in[,\"hour\"])\n                )\n\ncomb_data_in$concen[comb_data_in$concen == 0] <- 1e-6 # gamma distributed\n\nconcen.stk <- inla.stack(data = list(Y = comb_data_in$concen),\n                                 A = list(sp_indices_dens$A.mat, 1), \n                           effects = conc.lst,   \n                               tag = \"conc.0\")\n\nj.conc.stk <- inla.stack(data = list(Y = cbind(NA, comb_data_in$concen), link = 2),\n                                 A = list(sp_indices_dens$A.mat, 1), \n                           effects = conc.lst,   \n                               tag = \"conc.0\")\n\n\n\n\nCombine Stacks\nCombine the probability and and concentration data.\n\n\nHide code\njoint.stack <- inla.stack(j.dens.stk, j.conc.stk)"
  },
  {
    "objectID": "simulate_outbreak.html#run-joint-spatiotemporal-model",
    "href": "simulate_outbreak.html#run-joint-spatiotemporal-model",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Run Joint Spatiotemporal Model",
    "text": "Run Joint Spatiotemporal Model\nThe run_joint_spatiotemporal() is a wrapper function to facilitate model fitting with r-INLA. The model formula and execution can be viewed here: Model Details\n\n\nHide code\nbin_gamma_model <- run_joint_spatiotemporal(field.sp.1 = sp_indices_dens$field.sp.1,\n                                            field.sp.2 = sp_indices_dens$field.sp.2,\n                                            spde_prior = sp_indices_dens$spde0,\n                                            est.stk = joint.stack,\n                                            verbose =TRUE)\n\n# copy to OSF for others to access (~112mb)\nosf_upload(osf_project_demo, path = here(\"local/assets/bg_model_2025-04-26.rds\"))\n\n\nDownload pre-run from OSF\n\n\nHide code\nosf_id <- osf_project_demo %>%\n  osf_ls_files() %>%\n  filter(name == \"bg_model_2025-04-26.rds\")\n\nosf_download(osf_id,\n             path = here(\"local/temp\"),\n             conflicts = \"overwrite\")\n\n\nRead spatiotemporal model\n\n\nHide code\nbin_gamma_model <- readRDS(\"local/temp/bg_model_2025-04-26.rds\")"
  },
  {
    "objectID": "simulate_outbreak.html#model-results",
    "href": "simulate_outbreak.html#model-results",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Model Results",
    "text": "Model Results\nInspecting a few spatiotemporal model outputs.\n\nGet Latent Fields\nThe get_spatial_rf() function spatial\n\n\nHide code\nrandom_latent_field <- get_spatial_rf(model = bin_gamma_model,\n                                      field_sp = sp_indices_dens$field.sp.1,\n                                      raster_template = study_area$grid,\n                                      mesh = mesh.dom\n)\n\n\n\n\nView Fields\n\n\nHide code\nplot_latent_stack(rast_stack=random_latent_field,\n                  farm_locs = study_area$farm_locs)\n\n\n\n\n\n\n\nParticle Probabilty\nExtracting the probability estimates for all locations in the study area.\n\n\nHide code\nparticle_probs <- extract_stmodel_estimates(model = bin_gamma_model,\n                                            stack = joint.stack,\n                                            stack_targ = \"dens.0\",\n                                            match_data = comb_data_in,\n                                            grid_label = \"concen\",\n                                            raster_template = study_area$grid)\n\n\n\n\nHide code\nplot_prob_stack(particle_probs)\n\n\n\n\n\n\n\nParticle Concentration\nExtracting estimated concentrations for all locations in the study area.\n\n\nHide code\nparticle_conc <- extract_stmodel_estimates(model = bin_gamma_model,\n                                            stack = joint.stack,\n                                            stack_targ = \"conc.0\",\n                                            match_data = comb_data_in,\n                                            grid_label = \"concen\",\n                                            raster_template = study_area$grid)\n\n\n\n\nHide code\nplot_conc_stack(particle_conc)\n\n\n\n\n\nOptionally, can convert particle density to mass concentration (g/m3) using convert_particle_to_mass_concentration().\n\n\nHide code\nmass_conc_stack <- particle_conc\n\nvalues(mass_conc_stack) <- convert_particle_to_mass_concentration(concentration_particles_m3 = values(mass_conc_stack),\n                                                                  pdiam_um = cfg$plume$pdiam,\n                                                                  density_g_cm3 = cfg$plume$density,\n                                                                  shape_factor = cfg$plume$shape_factor,\n                                                                  output_units = \"g/m3\")"
  },
  {
    "objectID": "simulate_outbreak.html#farm-introduction-probability",
    "href": "simulate_outbreak.html#farm-introduction-probability",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Farm Introduction Probability",
    "text": "Farm Introduction Probability\nComparing particle probability estimates for simulated farm locations.\n\n\nHide code\nfarm_intro_probs <- extract_farm_estimates(model = bin_gamma_model,\n                                           stack = joint.stack,\n                                           stack_targ = \"dens.0\",\n                                           match_data = comb_data_in)\n\n\n\nProbability at farms\n\n\nHide code\nfarm_intro_probs$plot\n\n\n\n\n\nFiltering to simulated farms with at least a 50/% chance of particle occurrence.\n\n\nHide code\nexposed_farms <- farm_intro_probs$table %>%\n  filter(med >= 0.5 & name != \"source_farm\") # 50% chnace or higher\n\nexposed_farms\n\n\n\n\n\n\nname\nlabel\nlow\nmed\nhigh\nflock\n\n\n\n\nfarm_18\nFarm 18\n0.9823\n0.9854\n0.9868\n22574"
  },
  {
    "objectID": "simulate_outbreak.html#secondary-outbreak",
    "href": "simulate_outbreak.html#secondary-outbreak",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Secondary Outbreak",
    "text": "Secondary Outbreak\nGiven the high probability of particle introduction at a farm another than the source_farm, approximate how an outbreak might unfold based on that farmâs flock size, timeline of introdtcon, and other charcateristics.\n\nSEIR model for secondary ourbreak\n\n\nHide code\ninfect_date <- as_date(simulated_realease_dt)\n\nintro_farm_args <- list(\n  beta       = cfg$seir$beta,\n  sigma      = 1 / cfg$seir$sigma,\n  gamma      = 1 / cfg$seir$gamma,\n  qV         = cfg$virus$qV,\n  Vh         = cfg$poultry$house_vol,\n  Q          = cfg$poultry$Q_m3_h * 24,\n  lamd       = log(2) / halflife,\n  flock_size = exposed_farms$flock, # flock size where virus introduced\n  Ei         = cfg$seir$Ei,\n  Ii         = cfg$seir$Ii,\n  Ri         = cfg$seir$Ri,\n  Vi         = cfg$seir$Vi,\n  sim_days   = cfg$seir$sim_days,\n  infect_date = infect_date # infection same day as emission (only hours difference)\n)\n\nseir_exposed_farm <- do.call(model_seir_shedding, intro_farm_args)\n\n\nOutbreak at exposed farm. For rand_detect_day, assuming detection occurs 5 to 20 days after outbreaks start. That is, when workers notice that death rates are exceeding the normal background rate.\n\n\nHide code\nset.seed(1976)\nrand_detect_day <- round(runif(1, 5, 20),0)\ndetection_date <- infect_date + days(rand_detect_day)\n\n\n\n\nView outbreak dynamics\n\n\nHide code\nplot_ode_shed_dynamics(seir_exposed_farm, date_axis = TRUE, vline = detection_date, vline_text = \"Detection\")"
  },
  {
    "objectID": "simulate_outbreak.html#write-simulation-result",
    "href": "simulate_outbreak.html#write-simulation-result",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Write Simulation Result",
    "text": "Write Simulation Result\nRecording outbreak simulation info to be used in downstream analysis.\n\n\nHide code\nfarms_wgs84 <- project(study_area$farm_locs, \"EPSG:4326\") # long/lat\n\nsimulation_keep <- as.data.frame(farms_wgs84, geom=\"xy\") %>%\n  mutate(outbreak = if_else(name == exposed_farms$name, detection_date,\n         if_else(name == \"source_farm\", sim_dates$release_date, NA)))\n\n\nWrite copies locally and on OSF\n\n\nHide code\n# local copy\nwrite.csv(simulation_keep, here(\"local/assets/demo_outbreak_sim_2025-04-28.csv\"))\n\n# copy to OSF for others to access\nosf_upload(osf_project_demo, path = here(\"local/assets/demo_outbreak_sim_2025-04-28.csv\"))"
  },
  {
    "objectID": "simulate_outbreak.html#closing",
    "href": "simulate_outbreak.html#closing",
    "title": "Simulate Airborne Virus Introduction and Outbreak",
    "section": "Closing",
    "text": "Closing\nThis script simualted a pathogen plume from a source farm location followed secondary outbreaks at other farms downwind. Next, the results here are analysed in the script HERE to determine if that outbreak can be traced back to the orginal source farm. ```"
  },
  {
    "objectID": "trace_emission_source.html",
    "href": "trace_emission_source.html",
    "title": "Identify and Trace Plume Emission Source",
    "section": "",
    "text": "This script provides a conceptual workflow that backtraces or verifies the source farm that instigated secondary outbreaks at other farms through atmospheric dispersion of virus. That is, the script looks at data from a secondary outbreak and attempts to determine what source farm emitted the virus that seeded virus introduction. This script moves backward in time to identify the source of a pathogenic plume.\nThe companion and preceding script for this analysis is available here, Simulated Outbreak. That analysis moves forward in time to model what farms could have been subject to pathogen invasion after plume emission from a source farm. This preliminary script provides a more intuitive overview than the current one which requires a hindsight perspective."
  },
  {
    "objectID": "trace_emission_source.html#preliminary-setup",
    "href": "trace_emission_source.html#preliminary-setup",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Preliminary Setup",
    "text": "Preliminary Setup\n\nLibraries\nThis workflow uses the renv package for package versioning and environmental management. The renv.lock file is included to facilitate package installain. See, renv::restore().\n\n\n\n\n\nCore Functions\nCustom functions\n\n\nHide code\nsource(here(\"R/utilities.R\"))\nsource_dir(here(\"R\"))\n\n\n\n\nAuthentication\nUser credentials to access data repository and API resources.\n\n\nHide code\nauthentications <- yaml::read_yaml(here(\"local\", \"secrets.yaml\"))\n\n\n\n\nAPI Registration\nStadia maps are used for backgrounds.\n\n\nHide code\nregister_stadiamaps(key = authentications$stadi_api)\n\n\n\n\nOSF Link\nModels and data generated from this script are stored at the Open Science Framework (OSF) for remote access. See, this OSF Project: https://osf.io/98hmt/\n\n\nHide code\nosf_auth(authentications$osf_token) # for write/admin privileges\n\n\nRegistered PAT from the provided token\n\n\nHide code\nosf_project_demo <- osf_retrieve_node(\"https://osf.io/su4yz/\")\n\nosf_project_demo$name # scratch directory on OSF EpiPlume project\n\n\n[1] \"Demonstration Data\""
  },
  {
    "objectID": "trace_emission_source.html#read-configuration-parameters",
    "href": "trace_emission_source.html#read-configuration-parameters",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Read Configuration Parameters",
    "text": "Read Configuration Parameters\nParameters for epidemiological and spatial analyses are recorded in configuration files. Loading the demonstration config file, which can be viewed here: Demo Configuration Parameters.\n\n\nHide code\ncfg <- yaml::read_yaml(here(\"config\", \"demo_2025-04-21.yaml\"))"
  },
  {
    "objectID": "trace_emission_source.html#simulated-outbreak",
    "href": "trace_emission_source.html#simulated-outbreak",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Simulated Outbreak",
    "text": "Simulated Outbreak\nDownloading and reading the data frame resulting from forward simulation in the Simulated Outbreak script. This file has the coordinates and outbreak detection date for the secondarily infected farms (only one in this demo run) and source farm.\n\n\nHide code\nosf_id <- osf_project_demo %>%\n  osf_ls_files() %>%\n  filter(name == \"demo_outbreak_sim_2025-04-28.csv\")\n\nosf_download(osf_id,\n             path = here(\"local/temp\"),\n             conflicts = \"overwrite\")\n\n\n\n\n\n\n\n\n\n\n\n\nname\nid\nlocal_path\nmeta\n\n\n\n\ndemo_outbreak_sim_2025-04-28.csv\n680faa9b91b1af0e5e7c5bb0\nlocal/temp/demo_outbreak_sim_2025-04-28.csv\ndemo_outbreak_sim_2025-04-28.csv , file , /680faa9b91b1af0e5e7c5bb0 , 1414 , osfstorage , /demo_outbreak_sim_2025-04-28.csv , 1745857179 , 1745857179 , 13361dc0fd02ffb1c1b27224e97d7469 , 1201290c6e31d84d575f9ad16d5c62ce9de5b16256a4d125933476e7bd3a7833 , 0 , TRUE , 1 , FALSE , https://api.osf.io/v2/files/680faa9b91b1af0e5e7c5bb0/ , https://files.osf.io/v1/resources/su4yz/providers/osfstorage/680faa9b91b1af0e5e7c5bb0 , https://files.osf.io/v1/resources/su4yz/providers/osfstorage/680faa9b91b1af0e5e7c5bb0 , https://files.osf.io/v1/resources/su4yz/providers/osfstorage/680faa9b91b1af0e5e7c5bb0 , https://osf.io/download/680faa9b91b1af0e5e7c5bb0/ , https://mfr.osf.io/render?url=https%3A%2F%2Fosf.io%2Fdownload%2F680faa9b91b1af0e5e7c5bb0%2F%3Fdirect%26mode%3Drender, https://osf.io/su4yz/files/osfstorage/680faa9b91b1af0e5e7c5bb0 , https://api.osf.io/v2/files/680faa9b91b1af0e5e7c5bb0/ , https://api.osf.io/v2/files/680c0182fd8f8cdc22d2b775/ , 680c0182fd8f8cdc22d2b775 , files , https://api.osf.io/v2/files/680faa9b91b1af0e5e7c5bb0/versions/ , https://api.osf.io/v2/nodes/su4yz/ , su4yz , nodes , https://api.osf.io/v2/nodes/su4yz/ , nodes , nodes , su4yz , https://api.osf.io/v2/files/680faa9b91b1af0e5e7c5bb0/cedar_metadata_records/\n\n\n\n\n\n\nHide code\nsimulated_outbreaks <- read.csv(here(\"local/temp/demo_outbreak_sim_2025-04-28.csv\")) %>%\n  filter(!is.na(outbreak)) # keeping only farms that experienced outbreak\n\n\n\nConvert to Points\nData frame to spatial points\n\n\nHide code\n# Long/Lat\nfarm_points_wgs84 <- vect(simulated_outbreaks,\n                          geom = c(\"x\", \"y\"),\n                          crs = \"EPSG:4326\")\n\n\nGet metadata for simulated farms\n\n\nHide code\noutbreak_farm_meta <- as.data.frame(farm_points_wgs84, geom=\"xy\") %>%\n  filter(name != \"source_farm\") %>%\n  select(-X) # row names\n\norig_source_meta <- as.data.frame(farm_points_wgs84, geom=\"xy\") %>%\n  filter(name == \"source_farm\") %>%\n  select(-X)"
  },
  {
    "objectID": "trace_emission_source.html#create-study-area",
    "href": "trace_emission_source.html#create-study-area",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Create Study Area",
    "text": "Create Study Area\nDefining a study area extent (raster grid) with the secondary outbreak farm at center. The original source farm is also depicted as reference. The define_study_domain() identifies the appropriate UTM and returns projected objects.\n\n\nHide code\nstudy_area_args <- c(\n  list(\n    source_origin = c(outbreak_farm_meta$x, outbreak_farm_meta$y),\n    extent_km = cfg$domain$extent_km,\n    res_m = cfg$domain$res_m  \n  )\n)\n\nstudy_area <- exec(define_study_domain, !!!study_area_args)\n\n# projected UTM\nfarm_points <- project(farm_points_wgs84, crs(study_area$projection))\n\n\n\nPlot study area\nThe circle at center is the secondarily infected farm; the goal is to look backward in time to demonstrate that the source farm (triangle, lower right) emitted the plume that gave rise to the outbreak at the center.\n\n\nHide code\nmap_grid(study_area$grid, source_loc = farm_points)"
  },
  {
    "objectID": "trace_emission_source.html#trajectory-models",
    "href": "trace_emission_source.html#trajectory-models",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Trajectory Models",
    "text": "Trajectory Models\nA HYSPLIT model is constructed assuming the secondary outbreak location was a receptor of the plume from an unknown source. The splitR package is used to call a HYSPLIT exceutable from R.\nTime limit to download meteorological data.\n\n\nHide code\ngetOption(\"timeout\")\n\n\n[1] 60\n\n\nHide code\noptions(timeout=10000)\n\n\n\nDate Determination\nDetermine dates and times to evaluate. Although it is known when the outbreak was detected at the secondary farm, it is not known when the virus was introduced nor when initial infection occurred. In practice, poultry workers would likely only detect an outbreak once the rate of daily chicken mortality sufficiently and consistently (multiple days) exceeded that typical background rate. In this example, itâs assumed that latent periods and initial spread from a single chicken took at least 3 days (earliest possible detection), but may have taken 20 days to detect. Therefore, this demo analyses more than two weeks in the past.\n\n\nHide code\nmodel_name <- gsub(\"_\", \"\", outbreak_farm_meta$name) # 6 characters max\nmodel_name\n\n\n[1] \"farm18\"\n\n\nHide code\nearliest_date <- as_date(outbreak_farm_meta$outbreak) - days(20) # assuming slow to detect\nlatest_date <- as_date(outbreak_farm_meta$outbreak) - days(3) # allowing for at least 2 day latent period and 1 day infectious\n\ndates_to_check <- seq(earliest_date, latest_date, by = 1)\nlength(dates_to_check) # total days to model\n\n\n[1] 18\n\n\n\n\nRun Trajectory Model\nThe wrap_trajectory_model() saves locally, but a copy is also saved to OSF for others to use. There are a ton of parameter assumptions here to discuss. Brief explanations are provided with the config file (linked here), but its too much for this draft workflow.\nThis model estimates four trajectories per day (every 6 hours) for each of the 18 days, for a a total of 72 trajectories.\n\n\nHide code\ntraj_model <- wrap_trajectory_model(cfg, # configuration file\n                                    traj_name = model_name,\n                                    lon = outbreak_farm_meta$x, # simulated outbreak farm\n                                    lat = outbreak_farm_meta$y, # simulated outbreak farm\n                                    height = cfg$trajectory$traj_height,\n                                    duration = cfg$trajectory$traj_duration,\n                                    days = dates_to_check, # days to assess based on simulated outbreak timeline\n                                    daily_hours = cfg$trajectory$daily_hours,\n                                    model_height = cfg$trajectory$model_height, \n                                    direction = cfg$trajectory$traj_direction,\n                                    extended_met = cfg$trajectory$extended_met,\n                                    vert_motion = cfg$trajectory$vert_motion,\n                                    met_type = cfg$trajectory$traj_met_type,\n                                    met_dir = here(cfg$trajectory$traj_climate),\n                                    exec_dir = here(cfg$trajectory$traj_outputs),\n                                    clean_up = cfg$trajectory$traj_clean_up\n                                )\n\n# save copy to OSF\nosf_upload(osf_project_demo, path = here(\"local/demo_run/traj/farm18_model.rds\"))\n\n\nDownload trajectory model from OSF (if not run locally)\n\n\nHide code\nosf_id <- osf_project_demo %>%\n  osf_ls_files() %>%\n  filter(name == \"farm18_model.rds\")\n\nosf_download(osf_id,\n             path = here(\"local/temp\"),\n             conflicts = \"overwrite\")\n\n\nRead the pre-run trajectory model\n\n\nHide code\ntraj_model <- readRDS(here(\"local/temp/farm18_model.rds\"))\n\n\n\n\nPlot hindcast trajectories\nEach line is a trajectory extending from the secondarily infected farm (center) that follows atmospheric characteristics for the hind cast date and time. This plot shows the complete trajectory.\n\n\nHide code\nmap_grid2(study_area$grid, traj_model$traj_df, group_col = \"run\", vector_type = \"line\", grid_cut = FALSE)\n\n\n\n\n\nThe trajectories in this plot are cropped to the extent of study area with option grid_cut to better see individual paths.\nQuestion: Do any of these trajectories help identify and confirm the source farm?\n\n\nHide code\nmap_grid3(study_area$grid, traj_model$traj_df, group_col = \"run\", vector_type = \"line\", source_loc = farm_points_wgs84, grid_cut = TRUE)"
  },
  {
    "objectID": "trace_emission_source.html#spatial-analysis",
    "href": "trace_emission_source.html#spatial-analysis",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Spatial Analysis",
    "text": "Spatial Analysis\nA couple basic steps to compare distances between the source farm and possible trajectories from the secondary outbreak farm.\n\nMeasure distances\nThe measure_proximty() function measures distances for both the trajectory lines and point outputs.\n\n\nHide code\ntraj_dists <- measure_proximty(\n  target_location = c(orig_source_meta$x, orig_source_meta$y), # suspected source farm\n  traj_model = traj_model,\n  projection = study_area$projection\n  )\n\n\n\n\nInverse Distance Decay\nApply an inverse distance decay function assuming that trajectory probability decreases the further from the source farm it is:\n\nw(d) = \\exp(-\\lambda \\times d)\n\nwhere:\n- w(d) is the weight (between 0 and 1),\n- d is the distance in meters between the source and the trajectory,\n- \\lambda is a decay rate parameter, how quickly the weight decreases with distance.\n\n\nHide code\ndistance_threshold <- 10000 # meters, 10k, decreasing probability of trajectory after this distance\n\nlambda_value <- calibrate_lambda(distance_threshold, weight_target = 0.5) # find the best lambda with 10k as the median probability\n\n\nShow the relationship (green is the lambda_value).\n\n\nHide code\nplot_distance_decay(\n    lambda_target = lambda_value,\n    weight_target = 0.5 # median probability\n)\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nâ¹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nScore and Subset\nCalculate the probability for each modeled trajectory\n\n\nHide code\ntraj_dists$traj_lines$score <- calculate_inverse_distance_weight(traj_dists$traj_lines$distance_m, \n                                                                 lambda = lambda_value) # score distances\n\n\nSelect trajectories with at least a 90% probability.\n\n\nHide code\nclosest_traj_line <- as.data.frame(traj_dists$traj_lines) %>%\n  filter(score >= 0.9) %>%\n  arrange(desc(score)) %>%\n  select(run, distance_m, score)\n\n\nFilter trajectory data to possible distances.\n\n\nHide code\nruns_50 <- unique(closest_traj_line$run)\n\npossible_dates <- vect(traj_dists$traj_point)\npossible_dates <- project(possible_dates, \"EPSG:4326\" )\npossible_dates <- as.data.frame(possible_dates,\n                                geom=\"xy\") %>%\n  mutate(lon = x, lat = y) %>%\n  filter(run %in% runs_50)\n\n\nThe above reduced 72 possible trajectories to 1970-01-07, 1970-01-11, 1970-01-16, 1970-01-17 probable ones. Show here:\n\n\nHide code\nmap_grid3(study_area$grid, possible_dates, group_col = \"run\", vector_type = \"line\", source_loc = farm_points_wgs84, grid_cut = TRUE)"
  },
  {
    "objectID": "trace_emission_source.html#receptor-return",
    "href": "trace_emission_source.html#receptor-return",
    "title": "Identify and Trace Plume Emission Source",
    "section": "Receptor Return",
    "text": "Receptor Return\nHaving narrowed possible trajectory dates and times that could have produced the infecting plume, reverse plumes are simulated from the secondary outbreak farm (receptor) to the original source (nackwards in time).\nExecute plume model runs in a loop.\n\n\nHide code\npossible_datetimes <- possible_dates %>%\n  mutate(date = as.Date(traj_dt)) %>%\n  group_by(date) %>%\n  summarise(start = min(traj_dt)) %>%\n  as.data.frame()\n\nfor(i in 1:unique(possible_datetimes$start)){\n  \n  plume_name <- paste0(\"plume_\", i)\n  \n  plume_model <- wrap_plume_model(cfg, # configuration file\n                                plume_name = plume_name, # name/label\n                                lon = outbreak_farm_meta$x, # secondary outbreak farm\n                                lat = outbreak_farm_meta$y, # secondary outbreak farm\n                                direction = \"backward\", # from receptor back in time\n                                release_start = possible_datetimes$start[i], # release from source farm\n                                release_end = possible_datetimes$start[i] - hours(1), # reverse time\n                                start_time = possible_datetimes$start[i], # dispersion time same as emission\n                                end_time = possible_datetimes$start[i] - hours(24) # dispersion end\n                                )\n  \n  \n  \n}\n\n# copy to OSF\nosf_upload(osf_project_demo, path = here(\"local/demo_run/plume/plume_1_model.rds\"))\nosf_upload(osf_project_demo, path = here(\"local/demo_run/plume/plume_2_model.rds\"))\nosf_upload(osf_project_demo, path = here(\"local/demo_run/plume/plume_3_model.rds\"))\n\n\nDownload from OSF\n\n\nHide code\nosf_id <- osf_project_demo %>%\n  osf_ls_files() %>%\n  filter(name == \"plume_1_model.rds\" | \n         name == \"plume_2_model.rds\" |\n         name == \"plume_3_model.rds\")\n\nosf_download(osf_id,\n             path = here(\"local/temp\"),\n             conflicts = \"overwrite\")\n\n\nRead plume models\n\n\nHide code\nplume_1 <- readRDS(here(\"local/temp/plume_1_model.rds\"))\nplume_2 <- readRDS(here(\"local/temp/plume_2_model.rds\"))\nplume_3 <- readRDS(here(\"local/temp/plume_3_model.rds\"))\n\n\n\nPlume 1 simulated dispersion\n\n\nHide code\nmap_grid3(study_area$grid, plume_1$disp_df, group_col = \"particle_i\", vector_type = \"point\", source_loc = farm_points_wgs84, grid_cut = TRUE)\n\n\n\n\n\n\n\nPlume 2 simulated dispersion\n\n\nHide code\nmap_grid3(study_area$grid, plume_2$disp_df, group_col = \"particle_i\", vector_type = \"point\", source_loc = farm_points_wgs84, grid_cut = TRUE)\n\n\n\n\n\n\n\nPlume 3 simulated dispersion\n\n\nHide code\nmap_grid3(study_area$grid, plume_3$disp_df, group_col = \"particle_i\", vector_type = \"point\", source_loc = farm_points_wgs84, grid_cut = TRUE)"
  }
]